package org.jlab.rec.ahdc.KalmanFilter;

import org.apache.commons.math3.linear.MatrixUtils;
import org.apache.commons.math3.linear.RealMatrix;
import org.apache.commons.math3.linear.RealMatrixFormat;
import org.jetbrains.annotations.NotNull;
import org.jlab.clas.clas.math.FastMath;
import org.jlab.clas.swimtools.Swim;
import org.jlab.clas.tracking.kalmanfilter.Surface;

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;

public class KalmanFilter5D {

    boolean debug = false;

    RealMatrixFormat TABLE_FORMAT = new RealMatrixFormat("", "", "", "\n", "", ", ");

    Swim swim;

    double B = 5; // magnetic field in Tesla
    double c = 0.000299792458; // speed of light for conversion in GeV and mm
    double alpha = 1 / (B * c);

    List<StateVector> ExtrapoleStateVectors;
    List<StateVector> UpdateStateVectors;
    List<StateVector> SmoothStateVectors;

    List<RealMatrix> ExtrapolateCovarianceMatrices;
    List<RealMatrix> UpdateCovarianceMatrices;
    List<RealMatrix> SmoothCovarianceMatrices;

    List<RealMatrix> FMatrices;

    public static class MeasurementPoint{

        public double xo;
        public double yo;
        public double zo;
        public RealMatrix m;

        public MeasurementPoint(double x, double y, double z){
            this.xo = x;
            this.yo = y;
            this.zo = z;
            this.m = MatrixUtils.createRealMatrix(3, 1);
            m.setColumn(0, new double[]{x,y,z});
        }

        @Override
        public String toString() {
            return "MeasurementPoint{" +
                    "xo=" + xo +
                    ", yo=" + yo +
                    ", zo=" + zo +
                    '}';
        }
    }

    public static class StateVector {
        Swim swim;
        int k;
        double d_rho;
        double phi_0;
        double kappa;
        double dz;
        double tanL;
        RealMatrix a;
        MeasurementPoint m;
        double pathlenght;

        public StateVector(int k, double x, double y, double z, double px, double py, double pz, MeasurementPoint m, double pathlenght, Swim swim){
            this.k = k;
            this.m = m;
            this.pathlenght = pathlenght;
            this.swim = swim;

            transformPosAndMomToStateVector(x,y,z,px,py,pz);
        }

        public StateVector(int k, RealMatrix a, MeasurementPoint m, double pathlenght){
            this.k = k;
            this.d_rho = a.getEntry(0,0);
            this.phi_0 = a.getEntry(1,0);
            this.kappa = a.getEntry(2,0);
            this.dz =    a.getEntry(3,0);
            this.tanL =  a.getEntry(4,0);
            this.a = a;
            this.m = m;
            this.pathlenght = pathlenght;
        }

        public StateVector(int k, double d_rho, double phi_0, double kappa, double dz, double tanL, MeasurementPoint m, double pathlenght){
            this.k = k;
            this.d_rho = d_rho;
            this.phi_0 = phi_0;
            this.kappa = kappa;
            this.dz =    dz;
            this.tanL =  tanL;
            this.pathlenght = pathlenght;

            this.a = MatrixUtils.createRealMatrix(5,1);
            a.setColumn(0,new double[]{d_rho,phi_0,kappa,dz,tanL});

            this.m = m;
        }

        private void transformPosAndMomToStateVector(double x, double y, double z, double px, double py, double pz) {
            double kappa = 1. / Math.sqrt(px * px + py * py);

            double xo = m.xo;
            double yo = m.yo;
            double zo = m.zo;

            double d_rho_1 = Math.sqrt((x-xo)*(x-xo) + (y-yo)*(y-yo));

            double phi_0_1 = Math.atan2(-px,py);
            double tanL1 = pz * kappa;
            double dz1 = z - zo;

            this.d_rho = d_rho_1;
            this.phi_0 = phi_0_1;
            this.kappa = kappa;
            this.dz = dz1;
            this.tanL = tanL1;

            this.a = MatrixUtils.createRealMatrix(5, 1);
            a.setColumn(0, new double[]{d_rho, phi_0, kappa, dz, tanL});
        }

        @Override
        public String toString() {
            double x = m.xo + d_rho * Math.cos(phi_0);
            double y = m.yo + d_rho * Math.sin(phi_0);
            double z = m.zo + dz;
            double px = -1. / Math.abs(kappa) * Math.sin(phi_0);
            double py = 1. / Math.abs(kappa) * Math.cos(phi_0);
            double pz = 1. / Math.abs(kappa) * tanL;
            return "StateVector{" +
                    "k=" + k +
                    ", d_rho=" + d_rho +
                    ", phi_0=" + phi_0 +
                    ", kappa=" + kappa +
                    ", dz=" + dz +
                    ", tanL=" + tanL +
                    ", distance totale =" + Math.hypot(dz,d_rho) +
                    ", x =" + x +
                    ", y =" + y +
                    ", z =" + z +
                    ", px =" + px +
                    ", py =" + py +
                    ", pz =" + pz +
                    ", p = " + Math.sqrt(px*px+py*py+pz*pz) +
                    ", meas x = " + m.xo +
                    ", meas y = " + m.yo +
                    ", meas z = " + m.zo +
                    '}'+'\n';
        }
    }


    public KalmanFilter5D(Swim swimmer) {
        swim = swimmer;
    }

    public void runKalmanFilter(double[] starting, @NotNull List<Surface> measSurfaces, double p_gf, double phi_gf, double theta_gf) {


        // Create list MeasurementPoint :
        int i = 0;
        List<MeasurementPoint> measPoints = new ArrayList<>();
        for (Surface meas : measSurfaces) {
            measPoints.add(new MeasurementPoint(meas.refPoint.x(), meas.refPoint.y(), meas.refPoint.z()));
            i++;
        }
        if (debug) for (int k = 0; k < measPoints.size() - 1; k++ ) System.out.println(measPoints.get(k));

        // Initialization des Lists :
        ExtrapoleStateVectors = new ArrayList<>(Collections.nCopies(i+2, null));
        UpdateStateVectors = new ArrayList<>(Collections.nCopies(i+2, null));
        SmoothStateVectors = new ArrayList<>(Collections.nCopies(i+2, null));
        ExtrapolateCovarianceMatrices = new ArrayList<>(Collections.nCopies(i+2, null));
        UpdateCovarianceMatrices = new ArrayList<>(Collections.nCopies(i+2, null));
        SmoothCovarianceMatrices = new ArrayList<>(Collections.nCopies(i+2, null));

        FMatrices = new ArrayList<>(Collections.nCopies(i+2, null));

        // Initialisation du state vector :
        //System.out.println("Starting : " + Arrays.toString(starting));
        StateVector aInit = new StateVector(1,starting[0],starting[1],starting[2],starting[3],starting[4],starting[5],measPoints.get(0),0,swim);
        UpdateStateVectors.set(0,aInit);
        if (debug) System.out.println(aInit);


        // Initialisation de la matrix de covariance :
        RealMatrix PInit = MatrixUtils.createRealMatrix(5,5);


/*
        aInit.d_rho = 1e-6;
        aInit.dz = 1e-6;


        PInit.setEntry(0,0,aInit.d_rho*aInit.d_rho);
        //PInit.setEntry(1,0,aInit.d_rho*aInit.phi_0);
        //PInit.setEntry(0,1,aInit.d_rho*aInit.phi_0);
        //PInit.setEntry(2,0,aInit.d_rho*aInit.kappa);
        //PInit.setEntry(0,2,aInit.d_rho*aInit.kappa);
        //PInit.setEntry(2,1,aInit.phi_0*aInit.kappa);
        //PInit.setEntry(1,2,aInit.phi_0*aInit.kappa);
        PInit.setEntry(1,1,aInit.phi_0*aInit.phi_0);
        PInit.setEntry(2,2,aInit.kappa*aInit.kappa);
        PInit.setEntry(3,3,aInit.dz*aInit.dz);
        //PInit.setEntry(3,4,aInit.tanL*aInit.dz);
        //PInit.setEntry(4,3,aInit.tanL*aInit.dz);
        PInit.setEntry(4,4,aInit.tanL*aInit.tanL);
*/




        PInit = MatrixUtils.createRealIdentityMatrix(5).scalarMultiply(1e-4);

        UpdateCovarianceMatrices.set(0,PInit);



        for (int j = 0; j < 1; j++) {
            for (int k = 0; k < measPoints.size() + 1; k++) {
                if (debug) System.out.println("k = " + k);
                // First Step
                if (k == 0){
                    StateVector ExtrapolateStateVector = f1(UpdateStateVectors.get(k),UpdateStateVectors.get(k).m,3.00000,1);
                    if (ExtrapolateStateVector == null) return;
                    energyLossInDeuterium(ExtrapolateStateVector,1);
                    if (debug) System.out.println(ExtrapolateStateVector);
                    if (Math.abs(ExtrapolateStateVector.d_rho) > 10 || Math.abs(ExtrapolateStateVector.dz) > 10) {
                        System.out.println("Error Distance k = 0");
                        //System.exit(0);
                        return;
                    }
                    ExtrapoleStateVectors.set(k + 1, ExtrapolateStateVector);

                    RealMatrix F = F(UpdateStateVectors.get(k), ExtrapoleStateVectors.get(k + 1));
                    RealMatrix FT = F.transpose();
                    RealMatrix Q = Q(ExtrapoleStateVectors.get(k + 1));
                    RealMatrix P = UpdateCovarianceMatrices.get(k);
                    RealMatrix FPFT = F.multiply(P).multiply(FT);
                    RealMatrix ExtrapolateCovarianceMatrix = FPFT.add(Q);

                    ExtrapolateCovarianceMatrices.set(k + 1, ExtrapolateCovarianceMatrix);
                    FMatrices.set(k + 1, F);

                    UpdateStateVectors.set(k + 1, ExtrapolateStateVector);
                    UpdateCovarianceMatrices.set(k+1,ExtrapolateCovarianceMatrix);

                }
                else if (k == 1){
                    StateVector ExtrapolateStateVector = f1(UpdateStateVectors.get(k),UpdateStateVectors.get(k).m,3.0600000,2);
                    if (ExtrapolateStateVector == null) return;
                    energyLossInKapton(ExtrapolateStateVector,1);
                    if (debug) System.out.println(ExtrapolateStateVector);
                    if (Math.abs(ExtrapolateStateVector.d_rho) > 10 || Math.abs(ExtrapolateStateVector.dz) > 10) {
                        System.out.println("Error Distance k = 1");
                        //System.exit(0);
                        return;
                    }
                    ExtrapoleStateVectors.set(k + 1, ExtrapolateStateVector);

                    RealMatrix F = F(UpdateStateVectors.get(k), ExtrapoleStateVectors.get(k + 1));
                    RealMatrix FT = F.transpose();
                    RealMatrix Q = Q(ExtrapoleStateVectors.get(k + 1));
                    RealMatrix P = UpdateCovarianceMatrices.get(k);
                    RealMatrix FPFT = F.multiply(P).multiply(FT);
                    RealMatrix ExtrapolateCovarianceMatrix = FPFT.add(Q);

                    ExtrapolateCovarianceMatrices.set(k + 1, ExtrapolateCovarianceMatrix);
                    FMatrices.set(k + 1, F);

                    UpdateStateVectors.set(k + 1, ExtrapolateStateVector);
                    UpdateCovarianceMatrices.set(k+1,ExtrapolateCovarianceMatrix);

                }
                else {
                    // Extrapolation du State Vector :
                    StateVector ExtrapolateStateVector = f1(UpdateStateVectors.get(k), UpdateStateVectors.get(k).m, measPoints.get(k - 1), k + 1);
                    if (ExtrapolateStateVector == null) return;
                    energyLossInGasMixture(ExtrapolateStateVector,1);
                    if (debug) System.out.println(ExtrapolateStateVector);
                    if (Math.abs(ExtrapolateStateVector.d_rho) > 10 || Math.abs(ExtrapolateStateVector.dz) > 10) {
                        System.out.println("Error Distance");
                        //System.exit(0);
                        return;
                    }
                    ExtrapoleStateVectors.set(k + 1, ExtrapolateStateVector);

                    RealMatrix F = F(UpdateStateVectors.get(k), ExtrapoleStateVectors.get(k + 1));
                    RealMatrix FT = F.transpose();
                    RealMatrix Q = Q(ExtrapoleStateVectors.get(k + 1));
                    RealMatrix P = UpdateCovarianceMatrices.get(k);
                    RealMatrix FPFT = F.multiply(P).multiply(FT);
                    RealMatrix ExtrapolateCovarianceMatrix = FPFT.add(Q);

                    ExtrapolateCovarianceMatrices.set(k + 1, ExtrapolateCovarianceMatrix);
                    FMatrices.set(k + 1, F);


/*
                    RealMatrix h = h(ExtrapoleStateVectors.get(k + 1));
                    RealMatrix H = H(ExtrapoleStateVectors.get(k + 1));
                    RealMatrix y = measPoints.get(k - 1).m.subtract(h);
                    RealMatrix R = MatrixUtils.createRealIdentityMatrix(3).scalarMultiply(9.67e-5);
                    RealMatrix HT = H.transpose();
                    P = ExtrapolateCovarianceMatrix;
                    RealMatrix HPHT = H.multiply(P).multiply(HT);
                    RealMatrix S = HPHT.add(R);

                    RealMatrix K = P.multiply(HT).multiply(MatrixUtils.inverse(S));
                    RealMatrix I = MatrixUtils.createRealIdentityMatrix(5);

                    if (debug) System.out.println("Ky = " + TABLE_FORMAT.format(K.multiply(y)));

                    RealMatrix a = ExtrapoleStateVectors.get(k+1).a;
                    a = a.add(K.multiply(y));
                    StateVector UpdateStateVector = new StateVector(k + 1, a, measPoints.get(k - 1),0);
                    UpdateStateVectors.set(k + 1, UpdateStateVector);

                    if (debug) System.out.println(UpdateStateVector);

                    RealMatrix UpdateCovarianceMatrix = (I.subtract(K.multiply(H))).multiply(ExtrapolateCovarianceMatrices.get(k + 1));
                    UpdateCovarianceMatrices.set(k + 1, UpdateCovarianceMatrix);
*/

                    UpdateStateVectors.set(k + 1, ExtrapolateStateVector);
                    UpdateCovarianceMatrices.set(k+1,ExtrapolateCovarianceMatrix);
                }
            }



            SmoothStateVectors.set(UpdateStateVectors.size() - 1, UpdateStateVectors.get(UpdateStateVectors.size() - 1));
            SmoothCovarianceMatrices.set(UpdateCovarianceMatrices.size() - 1, UpdateCovarianceMatrices.get(UpdateCovarianceMatrices.size() - 1));

            if (debug) System.out.println(SmoothStateVectors);

            if (debug) System.out.println("Smoother : ");
            // RTS Smoothing (Rauch-Tung-Striebel)

            for (int k = measPoints.size() + 1; k > 0; k--) {

                if (debug) System.out.println("k = " + k);

                RealMatrix FT = FMatrices.get(k).transpose();
                RealMatrix Update_P = UpdateCovarianceMatrices.get(k - 1);
                RealMatrix InverseExtrapolate_P = MatrixUtils.inverse(ExtrapolateCovarianceMatrices.get(k));

                RealMatrix A = Update_P.multiply(FT).multiply(InverseExtrapolate_P); // A_{k-1} = P_{k-1|k-1} F^T P_{k|k-1}^-1

                RealMatrix Update_x = UpdateStateVectors.get(k - 1).a;
                RealMatrix Smoothed_x = SmoothStateVectors.get(k).a;
                RealMatrix Extrapolate_x = ExtrapoleStateVectors.get(k).a;

                RealMatrix Inter = Smoothed_x.subtract(Extrapolate_x);
                RealMatrix Inter2 = A.multiply(Inter);
                RealMatrix xs = Update_x.add(Inter2); // x^s_{k-1} = x_{k-1|k-1} + A_{k-1} (x^s_{k} - x_{k|k-1})

                RealMatrix Extrapolate_P = ExtrapolateCovarianceMatrices.get(k);
                RealMatrix Smoothed_P = SmoothCovarianceMatrices.get(k);
                RealMatrix AT = A.transpose();
                RealMatrix Inter3 = Extrapolate_P.subtract(Smoothed_P);
                RealMatrix Inter4 = A.multiply(Inter3).multiply(AT);
                RealMatrix Ps = Update_P.subtract(Inter4); // P_{k-1}^s = P_{k-1|k-1} - A_{k-1} (P_{k|k-1} - P_{k}^s) A^T_{k-1}

                StateVector as = new StateVector(k - 1, xs, UpdateStateVectors.get(k-1).m,0);

                SmoothStateVectors.set(k - 1, as);
                SmoothCovarianceMatrices.set(k - 1, Ps);

                if (debug) System.out.println(as);
            }



        }

        // double kappa = UpdateStateVectors.get(UpdateStateVectors.size()-1).kappa;
        // double phi_0 = UpdateStateVectors.get(UpdateStateVectors.size()-1).phi_0;
        // double tanL = UpdateStateVectors.get(UpdateStateVectors.size()-1).tanL;
        double kappa = SmoothStateVectors.get(0).kappa;
        double phi_0 = SmoothStateVectors.get(0).phi_0;
        double tanL = SmoothStateVectors.get(0).tanL;
        double px = -1. / Math.abs(kappa) * Math.sin(phi_0);
        double py = 1. / Math.abs(kappa) * Math.cos(phi_0);
        double pz = 1. / Math.abs(kappa) * tanL;
        double p = Math.sqrt(px*px+py*py+pz*pz);

        double phi_kf = phi_0 + Math.PI/2;
        if(phi_kf > Math.PI) phi_kf-=2*Math.PI;
        if(phi_kf<-Math.PI) phi_kf+=2*Math.PI;
        phi_kf = Math.toDegrees(phi_kf);

        double theta_kf = Math.toDegrees(Math.PI - Math.atan(tanL) - Math.PI/2);

        if (debug) System.out.println("p_gf = " + p_gf);
        if (debug) System.out.println("p_kf = " + p);
        if (debug) System.out.println("phi_gf = " + phi_gf);
        if (debug) System.out.println("phi_kf = " + phi_kf);
        if (debug) System.out.println("theta_gf = " + theta_gf);
        if (debug) System.out.println("theta_kf = " + theta_kf);

        try {
            BufferedWriter writer = new BufferedWriter(new FileWriter("Geant4Info.txt", true));
            writer.write("mom_gf = " + p_gf + '\n');
            writer.write("mom_kf = " + p + '\n');
            writer.write("phi_gf = " + phi_gf + '\n');
            writer.write("phi_kf = " + phi_kf + '\n');
            writer.write("theta_gf = " + theta_gf + '\n');
            writer.write("theta_kf = " + theta_kf + '\n');
            writer.write('\n');
            writer.close();
        } catch (IOException e) {
            System.out.println("An error occurred.");
            e.printStackTrace();
        }




        if (debug) System.out.println("End !!!");
        if (debug) System.out.println();

    }


    private StateVector f1(StateVector a, MeasurementPoint m, MeasurementPoint m_prim, int k){

        double accuracy = 1e-7;
        double stepSize = 1e-5;

        double xo = a.m.xo + a.d_rho * Math.cos(a.phi_0);
        double yo = a.m.yo + a.d_rho * Math.sin(a.phi_0);
        double zo = a.m.zo + a.dz;
        double pxo = -1. / Math.abs(a.kappa) * Math.sin(a.phi_0);
        double pyo = 1. / Math.abs(a.kappa) * Math.cos(a.phi_0);
        double pzo = 1. / Math.abs(a.kappa) * a.tanL;

        if (debug) System.out.println("Swim : x = " + xo + " y = " + yo + " z = " + zo + " px = " + pxo + " pyo = " + pyo + " pzo = " + pzo);

        double xo_prim = m_prim.xo;
        double yo_prim = m_prim.yo;

        double r = Math.hypot(xo_prim,yo_prim);

        if (debug) System.out.println("expected r = " + r);

        swim.SetSwimParameters(xo/10,yo/10,zo/10,pxo,pyo,pzo,1,stepSize,accuracy);

        double[] swimParams = swim.SwimRho(r/10);

        if (debug) System.out.println("Swim Out : " + Arrays.toString(swimParams));

        try {
            double x = swimParams[0]*10;
            double y = swimParams[1]*10;
            double z = swimParams[2]*10;
            double px = swimParams[3];
            double py = swimParams[4];
            double pz = swimParams[5];
            if (debug) System.out.println(" reached r = " + Math.hypot(x,y));
            return new StateVector(k,x,y,z,px,py,pz,m_prim,swimParams[6],swim);

        }
        catch (NullPointerException e){
            System.out.println("swimParams is null ");
            return null;
        }


    }

    private StateVector f1(StateVector a, MeasurementPoint m, double r, int k){

        double accuracy = 1e-12;
        double stepSize = 1e-9;

        double xo = m.xo + a.d_rho * Math.cos(a.phi_0);
        double yo = m.yo + a.d_rho * Math.sin(a.phi_0);
        double zo = m.zo + a.dz;
        double pxo = -1. / Math.abs(a.kappa) * Math.sin(a.phi_0);
        double pyo = 1. / Math.abs(a.kappa) * Math.cos(a.phi_0);
        double pzo = 1. / Math.abs(a.kappa) * a.tanL;

        if (debug) System.out.println("Swim : x = " + xo + " y = " + yo + " z = " + zo + " px = " + pxo + " pyo = " + pyo + " pzo = " + pzo);

        swim.SetSwimParameters(xo/10,yo/10,zo/10,pxo,pyo,pzo,1,stepSize,accuracy);

        //double[] swimParams = swim.SwimToCylinder(r/10);
        double[] swimParams = swim.SwimRho(r/10);
        if (debug) System.out.println("Swim Out : " + Arrays.toString(swimParams));



        try {
            double x = swimParams[0]*10;
            double y = swimParams[1]*10;
            double z = swimParams[2]*10;
            double px = swimParams[3];
            double py = swimParams[4];
            double pz = swimParams[5];
            if (debug) System.out.println(" reached r = " + Math.hypot(x,y));
            MeasurementPoint m_prim = new MeasurementPoint(x,y,z);
            return new StateVector(k,x,y,z,px,py,pz,m_prim,swimParams[6],swim);

        }
        catch (NullPointerException e){
            System.out.println("swimParams is null ");
            return null;
        }
    }

    private RealMatrix F(StateVector a, StateVector a_prim){

        double d_rho = a.d_rho;
        double phi_0 = a.phi_0;
        double kappa = a.kappa;
        double dz = a.dz;
        double tanL = a.tanL;

        double fd_rho = a_prim.d_rho;
        double fphi_0 = a_prim.phi_0;
        double fkappa = a_prim.kappa;
        double fdz = a_prim.dz;
        double ftanL = a_prim.tanL;


        double dphi0_prm_del_drho = -1. / (fd_rho + alpha / kappa) * Math.sin(fphi_0 - phi_0);
        double dphi0_prm_del_phi0 = (d_rho + alpha / kappa) / (fd_rho + alpha / kappa) * Math.cos(fphi_0 - phi_0);
        double dphi0_prm_del_kappa = (alpha / (kappa*kappa)) / (fd_rho + alpha / kappa) * Math.sin(fphi_0 - phi_0);
        double dphi0_prm_del_dz = 0;
        double dphi0_prm_del_tanL = 0;

        double drho_prm_del_drho = Math.cos(fphi_0 - phi_0);
        double drho_prm_del_phi0 = (d_rho + alpha / kappa) * Math.sin(fphi_0 - phi_0);
        double drho_prm_del_kappa = (alpha / (kappa*kappa)) * (1 - Math.cos(fphi_0 - phi_0));
        double drho_prm_del_dz = 0;
        double drho_prm_del_tanL = 0;

        double dkappa_prm_del_drho = 0;
        double dkappa_prm_del_phi0 = 0;
        double dkappa_prm_del_dkappa = 1;
        double dkappa_prm_del_dz = 0;
        double dkappa_prm_del_tanL = 0;

        double dz_prm_del_drho = ((alpha / kappa) / (fd_rho + alpha / kappa)) * tanL * Math.sin(fphi_0 - phi_0);
        double dz_prm_del_phi0 = (alpha / kappa) * tanL * (1 - Math.cos(fphi_0 - phi_0) * (fd_rho + (alpha / kappa)) / (fd_rho + (alpha / kappa)));
        double dz_prm_del_kappa = (alpha / (kappa*kappa)) * tanL * (fphi_0 - phi_0 - Math.sin(fphi_0 - phi_0) * (alpha / kappa) / (fd_rho + alpha / kappa));
        double dz_prm_del_dz = 1;
        double dz_prm_del_tanL = -alpha * (fphi_0 - phi_0) / kappa;

        double dtanL_prm_del_drho = 0;
        double dtanL_prm_del_phi0 = 0;
        double dtanL_prm_del_dkappa = 0;
        double dtanL_prm_del_dz = 0;
        double dtanL_prm_del_tanL = 1;

        double[][] FMat = new double[][]{
                {drho_prm_del_drho, drho_prm_del_phi0, drho_prm_del_kappa, drho_prm_del_dz, drho_prm_del_tanL},
                {dphi0_prm_del_drho, dphi0_prm_del_phi0, dphi0_prm_del_kappa, dphi0_prm_del_dz, dphi0_prm_del_tanL},
                {dkappa_prm_del_drho, dkappa_prm_del_phi0, dkappa_prm_del_dkappa, dkappa_prm_del_dz, dkappa_prm_del_tanL},
                {dz_prm_del_drho, dz_prm_del_phi0, dz_prm_del_kappa, dz_prm_del_dz, dz_prm_del_tanL},
                {dtanL_prm_del_drho, dtanL_prm_del_phi0, dtanL_prm_del_dkappa, dtanL_prm_del_dz, dtanL_prm_del_tanL}
        };

        return MatrixUtils.createRealMatrix(FMat);

    }

    private RealMatrix Q(StateVector a){
        double pt = Math.abs(1. / a.kappa);
        double pz = pt * a.tanL;
        double p = Math.sqrt(pt * pt + pz * pz);
        double mass = 0.93827208816;   // proton mass in GeV/c^2
        double beta = p / Math.sqrt(p * p + mass * mass); // particle momentum

        // Gas miture for ALERT : 4He-CO2
        double w_He = 4 * 4.0026 / (4 * 4.0026 + 12.0107 + 2 * 15.999); // fraction by weight of helium
        double w_C = 12.0107 / (4 * 4.0026 + 12.0107 + 2 * 15.999); // fraction by weight of carbon
        double w_O = 2 * 15.999 / (4 * 4.0026 + 12.0107 + 2 * 15.999); // fraction by weight of oxygen

        double X0_He = 94.32; // Radiation length in g/cm2 found on https://pdg.lbl.gov/2020/AtomicNuclearProperties/HTML/helium_gas_He.html
        double X0_C = 42.7; // Radiation length in g/cm2 found on https://pdg.lbl.gov/2020/AtomicNuclearProperties/HTML/carbon_amorphous_C.html
        double X0_O = 34.24; // Radiation length in g/cm2 found on https://pdg.lbl.gov/2020/AtomicNuclearProperties/HTML/oxygen_gas.html

        double X0 = 1 / (w_He / X0_He + w_C / X0_C + w_O / X0_O); // radiation length for gas mixture

        double pathLenght = a.pathlenght;

        double sctRMS = 0.0141 / (beta * p) * Math.sqrt(pathLenght / X0) * (1 + 1./9. * Math.log10(pathLenght/X0)); // Lynch-Dahl formula

        double[][] q = {
                {0, 0, 0, 0, 0},
                {0, sctRMS * sctRMS * (1 + a.tanL * a.tanL), 0, 0, 0},
                {0, 0, sctRMS * sctRMS * (a.kappa * a.kappa * a.tanL
                        * a.tanL), 0, sctRMS * sctRMS * (a.kappa * a.tanL
                        * (1 + a.tanL*a.tanL))},
                {0, 0, 0, 0, 0},
                {0, 0, sctRMS * sctRMS * (a.kappa * a.tanL * (1 + a.tanL
                        * a.tanL)), 0, sctRMS * sctRMS * (1 + a.tanL*a.tanL)
                        * (1 + a.tanL * a.tanL)}};

        return MatrixUtils.createRealMatrix(q);
    }

    private RealMatrix h(RealMatrix q, RealMatrix q_prim, RealMatrix m, RealMatrix m_prim){

        double accuracy = 1e-12;
        double stepSize = 1e-9;

        double xo = m.getEntry(0,0) + q.getEntry(0,0)*Math.cos(q.getEntry(1,0));
        double yo = m.getEntry(1,0) + q.getEntry(0,0)*Math.sin(q.getEntry(1,0));
        double zo = m.getEntry(2,0) + q.getEntry(3,0);
        double pxo = -1./Math.abs(q.getEntry(2,0))*Math.sin(q.getEntry(1,0));
        double pyo = 1./Math.abs(q.getEntry(2,0))*Math.cos(q.getEntry(1,0));
        double pzo = 1./Math.abs(q.getEntry(2,0))*q.getEntry(4,0);

        swim.SetSwimParameters(xo/10,yo/10,zo/10,pxo,pyo,pzo,1,stepSize,accuracy);

        double r = Math.hypot(m_prim.getEntry(0,0),m_prim.getEntry(1,0));
        double[] swimParams = swim.SwimRho(r/10);

        double x = swimParams[0]*10;
        double y = swimParams[1]*10;
        double z = swimParams[2]*10;

        double meas_x = x - q_prim.getEntry(0,0)*Math.cos(q_prim.getEntry(1,0));
        double meas_y = y - q_prim.getEntry(0,0)*Math.cos(q_prim.getEntry(1,0));
        double meas_z = z - q_prim.getEntry(0,0)*Math.cos(q_prim.getEntry(1,0));

        RealMatrix h = MatrixUtils.createRealMatrix(3,1);
        h.setEntry(0,0,meas_x);
        h.setEntry(1,0,meas_y);
        h.setEntry(2,0,meas_z);

        return h;
    }

    private RealMatrix h(StateVector a){
        double x0 = a.m.xo + a.d_rho * Math.cos(a.phi_0);
        double y0 = a.m.yo + a.d_rho * Math.sin(a.phi_0);
        double z0 = a.m.zo + a.dz;

        RealMatrix h = MatrixUtils.createRealMatrix(3,1);
        h.setEntry(0,0,x0);
        h.setEntry(1,0,y0);
        h.setEntry(2,0,z0);

        return h;
    }

    private RealMatrix H(StateVector a){
        double[][] HMat;
        HMat = new double[][]{{Math.cos(a.phi_0),-a.d_rho*Math.sin(a.phi_0),0.,0.,0.},
                {Math.sin(a.phi_0),a.d_rho*Math.cos(a.phi_0),0.,0.,0.},
                {0.,0.,0.,1.,0.}
        };
        return MatrixUtils.createRealMatrix(HMat);
    }

    private void energyLossInKapton(StateVector a, int direction){

        double pathlength = a.pathlenght;

        double ΔE = -1.187E+02*1.42000E+00*pathlength/1000;
        if (direction == -1) ΔE = -ΔE;



        double pt = Math.abs(1. / a.kappa); // GeV
        double pz = pt * a.tanL; // GeV
        double p = Math.sqrt(pt * pt + pz * pz); // Gev

        double E = Math.sqrt(p*p + 0.938*0.938);

        double E_prim = E + ΔE;

        double p_prim = FastMath.sqrt(E_prim*E_prim - 0.938*0.938);

        double pt_prim = FastMath.sqrt(p_prim*p_prim - pz*pz);

        double kappa_prim = 1./Math.abs(pt_prim);


        a.kappa = kappa_prim;
        a.a.setEntry(2,0,kappa_prim);

    }

    private void energyLossInDeuterium(StateVector a, int direction){

        double pathlength = a.pathlenght;

        double MHe= 2.014101764;
        double rhoHelium = 5*101325*MHe/(8.31446261815324*293.15)*1e-6;
        double ΔE = -3.136E+02*rhoHelium*pathlength/1000;
        if (direction == -1) ΔE = -ΔE;

        double pt = Math.abs(1. / a.kappa); // GeV
        double pz = pt * a.tanL; // GeV
        double p = Math.sqrt(pt * pt + pz * pz); // Gev

        double E = Math.sqrt(p*p + 0.938*0.938);

        double E_prim = E + ΔE;

        double p_prim = FastMath.sqrt(E_prim*E_prim - 0.938*0.938);

        double pt_prim = FastMath.sqrt(p_prim*p_prim - pz*pz);

        double kappa_prim = 1./Math.abs(pt_prim);


        a.kappa = kappa_prim;
        a.a.setEntry(2,0,kappa_prim);
    }

    private void energyLossInGasMixture(StateVector a, int direction){

        double pathlength = a.pathlenght;

        double Mavg = 0.2*44.01+0.8*4.0026;
        double rhoGasMixture = 101325*Mavg/(8.31446261815324*293.15)*1e-6;

        double A_He = 4.002602; // atomic mass g mol-1
        double A_C = 12.0107; // g mol-1 found on https://pdg.lbl.gov/2020/AtomicNuclearProperties/HTML/carbon_amorphous_C.html
        double A_O = 15.999; // g mol-1 found on https://pdg.lbl.gov/2020/AtomicNuclearProperties/HTML/oxygen_gas.html

        double w_He = 0.8 * A_He / (0.8 * A_He + 0.2 * (A_C + 2 * A_O)); // weight fraction of the 1th element (helium)
        double w_CO2 = 0.2 * (A_C + 2 * A_O) / (0.8 * A_He + 0.2 * (A_C + 2 * A_O)); // weight fraction of the 2th element (CO2)

        double ΔE = -(w_CO2*1.136E+02 + w_He*1.360E+02)*rhoGasMixture * pathlength/1000; //GeV g cm-2
        if (direction == -1) ΔE = -ΔE;


        double pt = Math.abs(1. / a.kappa); // GeV
        double pz = pt * a.tanL; // GeV
        double p = Math.sqrt(pt * pt + pz * pz); // Gev

        double E = Math.sqrt(p*p + 0.938*0.938);

        double E_prim = E + ΔE;

        double p_prim = FastMath.sqrt(E_prim*E_prim - 0.938*0.938);

        double pt_prim = FastMath.sqrt(p_prim*p_prim - pz*pz);

        double kappa_prim = 1./Math.abs(pt_prim);


        a.kappa = kappa_prim;
        a.a.setEntry(2,0,kappa_prim);
    }

}
